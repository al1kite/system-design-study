## Cloud Native Architecture

앞서 설명했듯, 2010년부터 Anti-Fragile, 클라우드 네이티브 형태로 발전 되어왔다. 
기존 로컬이나 사내에서 구축 및 운영했던 시스템을 클라우드 환경으로 전환하기 위해 어떤 아키텍처를 가져야하는지 알아 볼 것.
클라우드 네이티브 아키텍처의 특징을 간략하게 정리하면 다음과 같다.

### 확장 가능한 아키텍처
첫번째는 시스템은 필요에 따라 확장 가능한 형태의 아키텍처로 발전. 시스템의 수평적 확장으로 인해 더 많은 사용자 요청을 처리할 수 있었고
이렇게 확장된 시스템으로 인해 시스템 보안을 분산시킴과 동시에 가용성을 보장할 수 있게 되었다.

보통 시스템 확장을 의미하는 스케일링으로는 스케일-업, 스케일-아웃이 있는데, 스케일-업은 하드웨어를 높이는 작업(시스템 CPU 메모리 스펙을 높임), 
스케일-아웃은 같은 사양의 서버, 즉 인스턴스를 여러대 배치하면서 동시에 더 많은 사용자를 처리할 수 있도록 하는 것.

보통 이렇게 시스템을 양적으로 늘리기 위해선 하드웨어 비용이 증가하게 되어있지만 클라우드 네이티브 아키텍처에서는 클라우드 서비스를 제공하는 업체로부터
가상의 서버, 스토리지, 네트워크 등을 빌려 사용함으로써 이러한 비용을 최소화 및 양적으로 증가한 시스템을 더이상 사용 안할 경우 다시 빌린 리소스를 반납해 
비용을 낮출 수 있게 되었다.

따라서 클라우드 네이티브에선 가상 서버 기술이 필수적. 기존 서버 가상화 방식에 더불어 컨테이너 방식 가상화 같이 사용.
또한 클라우드 네이티브에 구축된 가상 서버, 리소스들은 다양한 모니터링 도구를 이용해 시스템의 상황 및 리소스 사용량 등을 확인 가능.

### 탄력적 아키텍처
어플리케이션을 구성하는 각 기능을 분리된 서비스로 개발 및 통합, 배포에 걸리는 시간을 앞서 얘기한 CICD 자동화 파이프라인을 통해 처리해 시스템 환경에 적용 시간을 단축. 
엔터프라이즈 어플리케이션으로 갈 수록 개발 인력의 증가 뿐만 아니라, 수많은 개발 환경, 테스트환경, 심지어 실제 운영 환경 및 예비 서버를 고려해 준비해야 하기 때문에
무수히 많은 환경의 같은 내용을 서비스 배포 과정을 자동화되어 있지 않다면 개발자는 비즈니스 로직 개발 시간보다 빌드, 배포에 상당한 시간을 허비해야 한다.

마이크로서비스는 작게 분리된 독립적인 서비스라 했는데, 전체 어플리케이션을 구성하고 있는 도메인 특성에 따라 서비스 경계를 잘 구분하고 거기에 맞게 서비스를 개발해야 한다.
서로 분리된 서비스 간의 원활한 통신을 위해 종속성은 최소화, 상태를 갖지 않는 서비스를 제공하려 노력해야. 

전체 어플리케이션을 구축하는 마이크로서비스들은 자신들이 배포될 때 자신의 위치가 어디있는지 등록해야 하고, 그래야 다른 서비스들이나 외부 연결 타 시스템에서도 
해당 서비스를 검색 및 사용할 수 있다. 이렇게 마이크로서비스들의 존재는 디스커버리 서비스라는 곳에 등록/삭제되는 작업을 하게 된다.

### 장애 격리
마지막으로, 장애 복구에 뛰어나다는 특징을 갖고 있다. 여러개로 분리되어 개발되므로 작은 단위의 어플리케이션과도 같아서 한쪽에서 나는 오류 사항은 다른 쪽에 영향을 최소화 한다.
어떤 특정적 부분 수정해도 전체 서비스를 배포하는게 아닌, 특정 서비스만 배포하면 되기에 다른 시스템에 영향을 주지 않을 수 있게 된다.

